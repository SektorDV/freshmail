{"version":3,"sources":["freshmail-js/errors/FreshMailError.js","freshmail-js/errors/ExtendableError.js","freshmail-js/FreshMail.js","App.js","constants.js","serviceWorker.js","index.js"],"names":["FreshMailError","ExtendableError","message","payload","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","name","constructor","Error","captureStackTrace","assertThisInitialized","stack","HOST","PREFIX","CONTENT_TYPE","FreshMail","fm","api_key","api_secret","api","key","secret","http","host","prefix","contentType","url","method","arguments","length","undefined","json_data","JSON","stringify","full_url","concat","signature","console","log","request","hash","crypto","createHash","update","digest","headers","Content-Type","X-Rest-ApiKey","X-Rest-ApiSign","superagent","post","set","send","Promise","reject","get","query","then","res","status","body","errors","err","resolve","ping","email","subject","isHTML","defineProperty","subscriber","mail","list_hash","state","confirm","custom_fields","list","keys","lists","getLists","findSubscriberInLists","promises","_this2","Array","isArray","map","getSubscriber","subscriberListHash","success","failure","count","forEach","p","push","catch","results","field_name","tag","type","sendMail","messageHtml","App","_useState","useState","_useState2","slicedToArray","setMessageHtml","react_default","a","createElement","className","rows","cols","onChange","evt","target","value","onClick","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"iVAIeA,oJCHb,SAAAC,EAAYC,EAASC,GAAS,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAN,IAC5BG,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAJ,GAAAS,KAAAH,KAAML,KACDS,KAAOP,EAAKQ,YAAYD,KAC7BP,EAAKF,QAAUA,EACfE,EAAKD,QAAUA,GAAW,KACY,oBAA5BU,MAAMC,kBACdD,MAAMC,kBAANT,OAAAU,EAAA,EAAAV,CAAAD,GAA8BA,EAAKQ,aAEnCR,EAAKY,MAAS,IAAIH,MAAMX,GAAUc,MARRZ,yCADFS,SCIxBI,EAAO,6BACPC,EAAS,QACTC,EAAe,mBA2NNC,IC1NTC,EAAK,eDuBT,SAAAD,EAAYE,EAASC,GAAalB,OAAAC,EAAA,EAAAD,CAAAE,KAAAa,GAChCb,KAAKiB,IAAM,CACTC,IAAKH,EACLI,OAAQH,GAEVhB,KAAKoB,KAAO,CACVC,KAAMX,EACNY,OAAQX,EACRY,YAAaX,uDAiCTY,EAAK5B,GAA0B,IAAjB6B,EAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAR,OACzBG,EAAYjC,EAAUkC,KAAKC,UAAUnC,GAAW,GAChDoC,EAAQ,GAAAC,OAAMjC,KAAKoB,KAAKC,MAAhBY,OAAuBjC,KAAKoB,KAAKE,QAAjCW,OAA0CT,GAClDU,EAAS,GAAAD,OAAMjC,KAAKiB,IAAIC,IAAf,KAAAe,OAAsBjC,KAAKoB,KAAKE,QAAhCW,OAAyCT,GAAzCS,OAA+CJ,GAA/CI,OAA2DjC,KAAKiB,IAAIE,QACjFgB,QAAQC,IAAIF,GACZ,IAUIG,EAVAC,EAAOC,IACGC,WAAW,QACXC,OAAOP,GACPQ,OAAO,OACjBC,EAAU,CACZC,eAAgB5C,KAAKoB,KAAKG,YAC1BsB,gBAAiB7C,KAAKiB,IAAIC,IAC1B4B,iBAAkBR,GAIpB,GAAc,SAAXb,EACDY,EAAUU,IACGC,KAAKhB,GACLiB,IAAIN,GACJO,KAAKtD,OACd,IAAc,QAAX6B,EAMP,OAAO0B,QAAQC,OAAO3D,EAAc,wDAAAwC,OAAyDR,KAL7FY,EAAUU,IACGM,IAAIrB,GACJiB,IAAIN,GACJW,MAAM1D,GAKrB,OAAOyC,EACJkB,KAAK,SAACC,GACL,GAAkB,MAAfA,EAAIC,QAAkBD,EAAIE,KAAKC,OAAO,CACvC,IAAIC,EAAM,IAAInE,EAAe,+DAE7B,OADAmE,EAAIhE,QAAU4D,EAAIE,KAAKC,OAChBR,QAAQC,OAAOQ,GAEtB,OAAOT,QAAQU,QAAQL,EAAIE,uCAKd,IAAhBjC,EAAgBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAP,MACZ,OAAO1B,KAAKqC,QAAQ,OAAmB,SAAXZ,EAAoB,CAACqC,MAAM,QAAQlC,EAAWH,gCAGvEsC,EAAOC,EAASN,GAAsB,IAAhBO,EAAgBvC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACrC9B,EAAOE,OAAAoE,EAAA,EAAApE,CAAA,CACTqE,WAAYJ,EACZC,QAASA,GACRC,EAAS,OAAS,OAASP,GAE9B,OAAO1D,KAAKqC,QAAQ,OAAQzC,oCAGrBmE,EAAOC,EAASN,GACvB,OAAO1D,KAAKoE,KAAKL,EAAOC,EAASN,GAAM,oCAGhCK,EAAOC,EAASN,GACvB,OAAO1D,KAAKoE,KAAKL,EAAOC,EAASN,GAAM,yCAG3BK,EAAOM,GAAkD,IAAvCC,EAAuC5C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAA/B,EAAG6C,EAA4B7C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAlB,EAAG8C,EAAe9C,UAAAC,OAAA,EAAAD,UAAA,QAAAE,EACjEhC,EAAU,CAAEmE,QAAOU,KAAMJ,EAAWC,QAAOC,WAE/C,GAAGC,GAA0C,kBAAlBA,GAA8B1E,OAAO4E,KAAKF,GAAe7C,OAClF/B,EAAQ4E,cAAgBA,OACpB,GAAGA,EACP,OAAOrB,QAAQC,OACb,IAAI3D,EAAJ,4DAAAwC,cAAsFuC,KAI1F,OAAOxE,KAAKqC,QAAQ,iBAAkBzC,4CAGvBmE,EAAOM,GACtB,OAAOrE,KAAKqC,QAAQ,oBAAqB,CAAE0B,QAAOU,KAAMJ,uCAQxD,OAAOrE,KAAKqC,QAAQ,0BACjBkB,KAAK,SAACC,GAAD,OAASL,QAAQU,QAAQL,EAAIE,KAAKiB,+CAG9BZ,EAAOM,GACnB,IAAM7C,EAAG,kBAAAS,OAAqBoC,EAArB,KAAApC,OAAkC8B,GAC3C,OAAO/D,KAAKqC,QAAQb,OAAKI,EAAW,8CAGvBmC,GAAO,IAAAlE,EAAAG,KACpB,OAAOA,KAAK4E,WACTrB,KAAK,SAACoB,GAAD,OAAW9E,EAAKgF,sBAAsBd,EAAOY,mDAGjCZ,EAAOY,GAAO,IA6BJG,EA7BIC,EAAA/E,KAClC,OAAGgF,MAAMC,QAAQN,IAAUA,EAAMhD,QA4BHmD,EA1B1BH,EAAMO,IAAI,SAAAT,GAAI,OACZM,EAAKI,cAAcpB,EAAOU,EAAKW,oBAC9B7B,KAAK,SAACY,GAAD,MAAiB,CAACA,aAAYM,YAyBrC,IAAItB,QAAQ,SAACU,EAAST,GAC3B,IAAIiC,EAAU,GACVC,EAAU,GACVC,EAAQ,EACZT,EAASU,QAAQ,SAAAC,GACfA,EAAElC,KAAK,SAACC,GACN+B,IACAF,EAAQK,KAAKlC,GACV+B,IAAUT,EAASnD,SACjB0D,EAAQ1D,OAAQkC,EAAQwB,GACtBjC,EAAOkC,MAEbK,MAAM,SAAC/B,GACR2B,IACAD,EAAQI,KAAK9B,GACV2B,IAAUT,EAASnD,SACjB0D,EAAQ1D,OAAQkC,EAAQwB,GACtBjC,EAAOkC,WAzCb/B,KAAK,SAACqC,GAAD,OACNzC,QAAQU,QACN+B,EAAQV,IAAI,SAAC1B,GAAD,MAAU,CACpBa,UAAWb,EAAIiB,KAAKW,mBACpBhF,KAAMoD,EAAIiB,KAAKrE,KACf+D,WAAYX,EAAIW,iBAGnBwB,MAAM,WACP,OAAOxC,QAAQU,QAAQ,MAGlBV,QAAQC,OAAO,IAAI3D,EAAe,gEAIxB4E,EAAWwB,EAAYC,GAAe,IACrDlG,EAAU,CAAE0C,KAAM+B,EAAWjE,KAAMyF,EAAYE,KADMrE,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAH,GAGtD,OADGoE,IAAKlG,EAAQkG,IAAMA,GACf9F,KAAKqC,QAAQ,4BAA6BzC,uCAzJjD,OAAOI,KAAKoB,KAAKG,0BAWHA,GACdvB,KAAKoB,KAAKG,YAAcA,+BARxB,OAAOvB,KAAKoB,KAAKC,mBAWVA,GACPrB,KAAKoB,KAAKC,KAAOA,iCARjB,OAAOrB,KAAKoB,KAAKE,qBAWRA,GACTtB,KAAKoB,KAAKE,OAASA,WCxDZ,CCPW,mCACG,4CDSnB0E,EAAW,SAACC,GACfnF,EAAGgD,QA4BSoC,MAVf,WAAe,IAAAC,EACyBC,mBAAS,WADlCC,EAAAvG,OAAAwG,EAAA,EAAAxG,CAAAqG,EAAA,GACNF,EADMI,EAAA,GACOE,EADPF,EAAA,GAEb,OACEG,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAAA,YAAUE,KAAK,KAAKC,KAAK,MAAMC,SAAU,SAACC,GAAD,OAASR,EAAeQ,EAAIC,OAAOC,QAAQA,MAAOhB,IAC3FO,EAAAC,EAAAC,cAAA,UAAQQ,QAAS,kBAAMlB,EAASC,KAAhC,UEtBckB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOjB,EAAAC,EAAAC,cAACgB,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMxE,KAAK,SAAAyE,GACjCA,EAAaC","file":"static/js/main.acc720cb.chunk.js","sourcesContent":["import ExtendableError from './ExtendableError';\n\nclass FreshMailError extends ExtendableError {}\n\nexport default FreshMailError;\n","class ExtendableError extends Error {\n  constructor(message, payload) {\n    super(message);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.payload = payload || null;\n    if(typeof Error.captureStackTrace === 'function'){\n      Error.captureStackTrace(this, this.constructor);\n    }else{\n      this.stack = (new Error(message)).stack;\n    }\n  }\n}\n\nexport default ExtendableError;\n","import superagent from 'superagent';\nimport crypto from 'crypto';\nimport FreshMailError from './errors/FreshMailError';\n\nconst HOST = 'https://api.freshmail.com/';\nconst PREFIX = 'rest/';\nconst CONTENT_TYPE = 'application/json';\n\n/**\n * subscriber status codes for use with API: (undocumented in API)\n * 1 active\n * 2 activation pending\n * 3 not activated\n * 4 resigned\n * 5 soft bouncing\n * 8 hard bouncing\n**/\n\n/**\n * Custom class for Freshmail REST API\n * @author: Dariusz Stepniak <stepniak.dariusz@gmail.com>\n * @author: Philippe Hebert <philippe.hebert.qc@gmail.com>\n**/\nclass FreshMail {\n  /**\n   * Create class instance, requires api_key and api_secret\n   * @param {string} api_key : The API key provided by FreshMail\n   * @param {string} api_secret : The API secret provided by FreshMail\n   * @return {FreshMail} FreshMail instance\n  **/\n  constructor(api_key, api_secret) {\n    this.api = {\n      key: api_key,\n      secret: api_secret\n    };\n    this.http = {\n      host: HOST,\n      prefix: PREFIX,\n      contentType: CONTENT_TYPE\n    };\n  }\n\n  get contentType() {\n    return this.http.contentType;\n  }\n\n  get host() {\n    return this.http.host;\n  }\n\n  get prefix() {\n    return this.http.prefix;\n  }\n\n  set contentType(contentType) {\n    this.http.contentType = contentType;\n  }\n\n  set host(host) {\n    this.http.host = host;\n  }\n\n  set prefix(prefix) {\n    this.http.prefix = prefix;\n  }\n\n  /**\n   * Makes request to REST API. Add payload data for POST request.\n   * @param {string} url: API endpoint pathname\n   * @param {object} payload: POST data serializable JSON object\n  **/\n  request(url, payload, method = 'POST') {\n    let json_data = payload ? JSON.stringify(payload) : '';\n    let full_url = `${this.http.host}${this.http.prefix}${url}`;\n    let signature = `${this.api.key}/${this.http.prefix}${url}${json_data}${this.api.secret}`;\n    console.log(signature);\n    let hash = crypto\n                 .createHash('sha1')\n                 .update(signature)\n                 .digest('hex');\n    let headers = {\n      'Content-Type': this.http.contentType,\n      'X-Rest-ApiKey': this.api.key,\n      'X-Rest-ApiSign': hash\n    };\n\n    let request;\n    if(method === 'POST'){\n      request = superagent\n                  .post(full_url)\n                  .set(headers)\n                  .send(payload);\n    }else if(method === 'GET'){\n      request = superagent\n                  .get(full_url)\n                  .set(headers)\n                  .query(payload);\n    }else{\n      return Promise.reject(FreshMailError(`FreshMail API only supports GET or POST methods; Got ${method}`));\n    }\n\n    return request\n      .then((res) => {\n        if(res.status !== 200 || res.body.errors){\n          let err = new FreshMailError('FreshMail API returned errors. See payload for more details');\n          err.payload = res.body.errors;\n          return Promise.reject(err);\n        }else{\n          return Promise.resolve(res.body);\n        }\n      });\n  }\n\n  ping(method = 'GET') {\n    return this.request('ping', method === 'POST' ? {ping: true} : undefined, method);\n  }\n\n  mail(email, subject, body, isHTML = false) {\n    let payload = {\n      subscriber: email,\n      subject: subject,\n      [isHTML ? 'html' : 'text']: body\n    };\n    return this.request('mail', payload);\n  }\n\n  mailText(email, subject, body) {\n    return this.mail(email, subject, body, false);\n  }\n\n  mailHTML(email, subject, body) {\n    return this.mail(email, subject, body, true);\n  }\n\n  addSubscriber(email, list_hash, state = 3, confirm = 0, custom_fields) {\n    let payload = { email, list: list_hash, state, confirm };\n\n    if(custom_fields && typeof custom_fields === 'object' && Object.keys(custom_fields).length){\n      payload.custom_fields = custom_fields;\n    }else if(custom_fields){\n      return Promise.reject(\n        new FreshMailError(`Invalid Argument: custom_fields must be an object. Got a ${typeof custom_fields}`)\n      );\n    }\n\n    return this.request('subscriber/add', payload);\n  }\n\n  deleteSubscriber(email, list_hash) {\n    return this.request('subscriber/delete', { email, list: list_hash });\n  }\n\n  // TODO: Create subscriber list\n\n  // TODO: Delete subscriber list\n\n  getLists() {\n    return this.request('subscribers_list/lists')\n      .then((res) => Promise.resolve(res.body.lists));\n  }\n\n  getSubscriber(email, list_hash) {\n    const url = `subscriber/get/${list_hash}/${email}`;\n    return this.request(url, undefined, 'GET');\n  }\n\n  findSubscriber(email) {\n    return this.getLists()\n      .then((lists) => this.findSubscriberInLists(email, lists));\n  }\n\n  findSubscriberInLists(email, lists) {\n    if(Array.isArray(lists) && lists.length){\n      return filter_rejected_promises(\n        lists.map(list =>\n          this.getSubscriber(email, list.subscriberListHash)\n          .then((subscriber) => ({subscriber, list}))\n      )).then((results) =>\n        Promise.resolve(\n          results.map((res) => ({\n            list_hash: res.list.subscriberListHash,\n            name: res.list.name,\n            subscriber: res.subscriber\n          })\n        )\n      )).catch(() => {\n        return Promise.resolve([]);\n      });\n    }else{\n      return Promise.reject(new FreshMailError('No lists found'));\n    }\n  }\n\n  addCustomFieldtoList(list_hash, field_name, tag, type = 0) {\n    let payload = { hash: list_hash, name: field_name, type };\n    if(tag) payload.tag = tag;\n    return this.request('subscribers_list/addField', payload);\n  }\n}\n\nfunction filter_rejected_promises(promises) {\n  return new Promise((resolve, reject) => {\n    let success = [];\n    let failure = [];\n    let count = 0;\n    promises.forEach(p => {\n      p.then((res) => {\n        count++;\n        success.push(res);\n        if(count === promises.length){\n          if(success.length) resolve(success);\n          else reject(failure);\n        }\n      }).catch((err) => {\n        count++;\n        failure.push(err);\n        if(count === promises.length){\n          if(success.length) resolve(success);\n          else reject(failure);\n        }\n      });\n    });\n  });\n}\n\nexport default FreshMail;\n","import React, {useState} from 'react';\nimport './App.css';\nimport FreshMail from './freshmail-js/FreshMail';\nimport  './constants';\nimport { APIKEY, APISECRET } from './constants';\nimport superagent from 'superagent';\n\nconst fm = new FreshMail(APIKEY, APISECRET);\n\n\nconst sendMail = (messageHtml) => {\n   fm.ping();\n  \n  const jsonData = {\n    subscriber: 'roman@sawblade.pl',\n    html: messageHtml,\n    subject: 'Test message'\n  }\n\n  // const APISIGN = sha1(APIKEY + '/rest/mail' + jsonData + APISECRET);\n  // const headers = {\n  //   'Content-type' : 'application/json',\n  //   'X-Rest-ApiKey': APIKEY,\n  //   'X-Rest-ApiSign': APISIGN\n  // }\n  // Axios.post('https://api.freshmail.com/rest/mail', jsonData, {headers : headers}).then(res => console.log('sent successfully. response: ', res)).catch(err => console.log('error: ', err))\n  // Axios.get('https://api.freshmail.com/rest/ping', {headers: headers})\n}\n\nfunction App() {\n  const [messageHtml, setMessageHtml] = useState('initial');\n  return (\n    <div className=\"App\">\n      <textarea rows=\"50\" cols=\"100\" onChange={(evt) => setMessageHtml(evt.target.value)} value={messageHtml}></textarea>\n      <button onClick={() => sendMail(messageHtml)}>Send</button>\n    </div>\n  );\n}\n\nexport default App;\n","export const APIKEY = \"47d9458081de7faa22e284276b1c17af\";\r\nexport const APISECRET = \"9607cdf2d6b2f86bce491261b69e64db0a7f5cc0\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}